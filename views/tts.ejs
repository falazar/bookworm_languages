
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title><%= title %></title>
    <style>
      /* Dark theme for comfortable reading */
      :root { --base-font: 17px; }
      body { font-family: system-ui, Arial, sans-serif; margin: 20px 10%; font-size: var(--base-font); background: #000; color: #e6e6e6; }
      header { display: flex; align-items: center; justify-content: space-between; gap: 12px; color: #d0d0d0; }
      .header-left { display: flex; align-items: center; gap: 12px; min-width: 0; }
      .book-name { max-width: 50vw; }
      .book-name code { display: inline-block; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .controls { display: flex; flex-wrap: wrap; gap: 12px; margin: 12px 0; }
      label { display: inline-flex; align-items: center; gap: 6px; }
      textarea { width: 100%; min-height: 120px; background: #0c0c0c; color: #e6e6e6; border: 1px solid #333; }
      input[type="range"] { min-width: 220px; }
      /* Unified dropdown styling */
      select {
        display: inline-block;
        width: fit-content;
        min-width: 0;
        max-width: 60vw;
        padding: 8px 12px;
        font-size: 16px;
        line-height: 1.25;
        background: #1c1f29;
        color: #f0f0f0;
        border: 1px solid #444;
        border-radius: 6px;
      }
      input[type="range"] { accent-color: #66a3ff; }
      button { padding: 6px 12px; background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; }
      .btn { padding: 6px 12px; background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; border-radius: 4px; text-decoration: none; display: inline-block; white-space: nowrap; }
      .settings-toggle { margin-left: 12px; }
      .settings-panel { display: none; flex-wrap: wrap; gap: 12px; margin-top: 12px; }
      .settings-panel.open { display: flex; }
      

      .para { margin: 8px 0; padding: 6px 8px; border-left: 3px solid #222; background: #0a0a0a; }
      /* Slight highlight and bold for both FR and EN paragraphs of the active pair */
      .para.paired { box-shadow: inset 0 0 0 9999px rgba(255, 255, 180, 0.06); font-weight: 700; }
      /* Stronger emphasis and light yellow text for the paragraph being read */
      .para.playing { border-left-color: #ffd54f; background: #2a240f; font-weight: 700; color: #ffeaa7; }
      .para.hidden { display: none; }
      /* Tint by language on dark */
      .para[data-lang="fr"] { border-left-color: #d83b01; background: #1a0f0a; }
      .para[data-lang="en"] { border-left-color: #107c10; background: #0f1a0f; }

      footer { margin-top: 16px; font-size: 13px; color: #a0a0a0; }

      .legend { display: flex; gap: 18px; align-items: center; margin: 32px 0 12px; font-size: 13px; color: #a0a0a0; }
      .swatch { width: 12px; height: 12px; display: inline-block; border: 1px solid #555; margin-right: 6px; }
      .swatch.fr { background: #1d120d; border-color: #d83b01; }
      .swatch.en { background: #101d10; border-color: #107c10; }
      .break { flex-basis: 100%; height: 0; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-left">
        <div class="book-name"><code><%= typeof book !== 'undefined' ? book : '' %></code></div>
      </div>
      <div>
        <a href="/books" class="btn">← Back to Books</a>
      </div>
    </header>

    <div class="controls">
      <label>
        Chapter
        <select id="docSelect"></select>
      </label>
      <button id="settingsToggle" class="btn settings-toggle">Settings</button>

      <div id="settingsPanel" class="settings-panel">
        <label>
          Show
          <select id="showLang">
            <option value="both">Both</option>
            <option value="en">English only</option>
            <option value="fr">French only</option>
          </select>
        </label>
        <label style="display:none">
          Book
          <select id="bookSelect"></select>
        </label>

        <label>
          Font Size
          <input id="fontSize" type="range" min="15" max="26" step="1" value="17" />
        </label>
        <div class="break"></div>
        <label>
          English Voice
          <select id="voiceSelectEn"></select>
        </label>
        <label>
          French Voice
          <select id="voiceSelectFr"></select>
        </label>
        <div class="break"></div>
        <label>
          English Rate
          <input id="rateEn" type="range" min="0.5" max="2.0" step="0.1" value="1.0" />
        </label>
        <label>
          French Rate
          <input id="rateFr" type="range" min="0.5" max="2.0" step="0.1" value="1.0" />
        </label>
        <label>
          Pitch
          <input id="pitch" type="range" min="0.8" max="1.2" step="0.05" value="1.0" />
        </label>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
        <button id="resume">Resume</button>
        <button id="stop">Stop</button>
      </div>
    </div>

    <div class="legend">
      <span><span class="swatch fr"></span>French (FR)</span>
      <span><span class="swatch en"></span>English (EN)</span>
      <span>Currently playing is highlighted.</span>
    </div>

    <section id="content">
      <% paragraphs.forEach(function(p, idx) { %>
        <div class="para" data-index="<%= idx %>" data-lang="<%= p.lang %>">
          <span><%= p.text %></span>
        </div>
      <% }) %>
    </section>
    <div style="margin-top: 16px;">
      <button id="nextChapter" class="btn">Next Chapter →</button>
    </div>

    <footer>
      Tip: Open this page in Chrome/Edge to access high-quality voices. Use the voice list to pick a "Google" voice if available.
    </footer>

    <script>
      const bookSelect = document.getElementById('bookSelect');
      const docSelect = document.getElementById('docSelect');
      const voiceSelectEn = document.getElementById('voiceSelectEn');
      const rateEn = document.getElementById('rateEn');
      const rateFr = document.getElementById('rateFr');
      const pitchInput = document.getElementById('pitch');
      const fontSizeInput = document.getElementById('fontSize');
      const showLangSelect = document.getElementById('showLang');
      const settingsToggleBtn = document.getElementById('settingsToggle');
      const settingsPanel = document.getElementById('settingsPanel');
      const btnPlay = document.getElementById('play');
      const btnPause = document.getElementById('pause');
      const btnResume = document.getElementById('resume');
      const btnStop = document.getElementById('stop');
      const paras = Array.from(document.querySelectorAll('.para'));
      // Add IDs to paragraphs for anchor navigation
      paras.forEach((p, i) => { p.id = 'p' + i; });
      const nextChapterBtn = document.getElementById('nextChapter');

      // Debug logging flag (enable via ?debug=1)
      const DEBUG_TTS = /[?&]debug=1/.test(location.search);
      function logState(prefix) {
        try {
          const s = window.speechSynthesis;
          if (DEBUG_TTS) console.log(`[TTS] ${prefix} | speaking=${s.speaking} paused=${s.paused} pending=${s.pending}`);
        } catch (_) {}
      }

      let voices = [];
      let queue = [];
      let currentIndex = -1;
      let userPaused = false;
      // Track currently playing paragraph index
      let currentPlayingIdx = -1;
      // Suppress synthetic click after touch to avoid double-handling
      let lastTouchTs = 0;

      // Keep screen awake while reading using the Screen Wake Lock API
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if (navigator.wakeLock && !wakeLock) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => { wakeLock = null; });
          }
        } catch (err) {
          console.warn('Wake Lock error:', err);
          wakeLock = null;
        }
      }
      async function releaseWakeLock() {
        try {
          if (wakeLock) {
            await wakeLock.release();
            wakeLock = null;
          }
        } catch (_) {}
      }

      // Try resume, fallback to restart if engine stays paused or idle
      function resumeOrRestart(idx) {
        logState('resumeOrRestart: before resume');
        try { requestWakeLock().catch(() => {}); } catch(_) {}
        try { window.speechSynthesis.resume(); } catch(_) {}
        setTimeout(() => {
          try {
            const s = window.speechSynthesis;
            // If still paused OR not speaking and no pending utterances, restart from the same paragraph
            if (s.paused || (!s.speaking && !s.pending)) {
              logState('resumeOrRestart: fallback restart');
              s.cancel();
              requestWakeLock().catch(() => {});
              speakParagraphs(idx);
            } else {
              logState('resumeOrRestart: resume took effect');
            }
          } catch(_) {}
        }, 180);
      }

      // Reacquire on visibility change (wake locks can be released when tab is hidden)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && (window.speechSynthesis.speaking || window.speechSynthesis.paused)) {
          requestWakeLock().catch(() => {});
        }
      });

      // Populate book/chapter selectors from server-provided list
      const books = <%- JSON.stringify(typeof books !== 'undefined' ? books : []) %>;
      const currentBook = <%- JSON.stringify(typeof book !== 'undefined' ? book : '') %>;
      const docs = <%- JSON.stringify(typeof docs !== 'undefined' ? docs : []) %>;
      const docLabels = <%- JSON.stringify(typeof docLabels !== 'undefined' ? docLabels : []) %>;
      const currentDoc = <%- JSON.stringify(typeof doc !== 'undefined' ? doc : '') %>;
      const paragraphData = <%- JSON.stringify(paragraphs || []) %>;
      const savedParagraphIndex = <%- JSON.stringify(typeof savedParagraphIndex !== 'undefined' ? savedParagraphIndex : 0) %>;

      // Check if localStorage is available
      function isLocalStorageAvailable() {
        try {
          const test = '__localStorage_test__';
          localStorage.setItem(test, test);
          localStorage.removeItem(test);
          return true;
        } catch (e) {
          console.warn('[TTS] localStorage not available:', e);
          return false;
        }
      }
      const localStorageAvailable = isLocalStorageAvailable();

      // Local storage keys
      const LS = {
        book: 'tts.selectedBook',
        doc: 'tts.selectedDoc',
        rateEn: 'tts.rateEn',
        rateFr: 'tts.rateFr',
        fontSize: 'tts.fontSize',
        showLang: 'tts.showLang',
      };

      function saveProgressToServer(paragraphIndex) {
        console.log('[TTS] Saving progress to server:', { book: currentBook, doc: currentDoc, paragraphIndex });
        fetch('/save-progress', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            book: currentBook,
            doc: currentDoc,
            paragraphIndex: paragraphIndex
          })
        }).then(() => {
          console.log('[TTS] Progress saved successfully');
        }).catch(err => {
          console.warn('[TTS] Failed to save progress:', err);
        });
      }

      function loadBooks() {
        bookSelect.innerHTML = '';
        books.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b;
          opt.textContent = b;
          bookSelect.appendChild(opt);
        });
        let storedBook;
        try { if (localStorageAvailable) storedBook = localStorage.getItem(LS.book); } catch(e) { console.warn('[TTS] localStorage error (book):', e); }
        const chosenBook = storedBook && books.includes(storedBook) ? storedBook : currentBook;
        if (chosenBook) {
          bookSelect.value = chosenBook;
        } else if (books.length > 0) {
          // No saved or current book; default to first and navigate to load chapters
          bookSelect.value = books[0];
          const url = new URL(window.location.href);
          url.searchParams.set('book', books[0]);
          url.searchParams.delete('doc');
          window.location.replace(url.toString());
          return;
        }
      }

      function loadDocs() {
        docSelect.innerHTML = '';
        docs.forEach((d, idx) => {
          const opt = document.createElement('option');
          opt.value = d;
          // For Flashback book, use filename instead of title since all titles are the same
          const isFlashback = currentBook && currentBook.toLowerCase().includes('flashback');
          let label;
          if (isFlashback) {
            // Strip directory path and parse filename like "OEBPS/chapter001.html" -> "Chapter 1"
            const filename = String(d).split('/').pop().split('\\').pop();
            const match = filename.match(/chapter(\d+)/i);
            label = match ? `Chapter ${parseInt(match[1], 10)}` : filename;
          } else {
            label = (Array.isArray(docLabels) && docLabels[idx]) ? String(docLabels[idx]) : String(d);
          }
          if (label.length > 30) label = label.slice(0, 27) + '…';
          opt.textContent = label;
          docSelect.appendChild(opt);
        });
        let storedDoc;
        try { if (localStorageAvailable) storedDoc = localStorage.getItem(LS.doc); } catch(e) { console.warn('[TTS] localStorage error (doc):', e); }
        const chosenDoc = storedDoc && docs.includes(storedDoc) ? storedDoc : currentDoc;
        if (chosenDoc) docSelect.value = chosenDoc;
      }

      function loadVoices() {
        voices = window.speechSynthesis.getVoices();
        // Populate English voices
        voiceSelectEn.innerHTML = '';
        voices.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `${v.name} — ${v.lang}${v.default ? ' (default)' : ''}`;
          voiceSelectEn.appendChild(opt);
        });
        // Populate French voices
        voiceSelectFr.innerHTML = '';
        voices.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `${v.name} — ${v.lang}${v.default ? ' (default)' : ''}`;
          voiceSelectFr.appendChild(opt);
        });

        // Prefer language-appropriate defaults
        const defaultEn = voices.findIndex(v => /^en(-|$)/i.test(v.lang));
        const defaultFr = voices.findIndex(v => /^fr(-|$)/i.test(v.lang));
        const googleEn = voices.findIndex(v => /^en(-|$)/i.test(v.lang) && /Google/i.test(v.name));
        const googleFr = voices.findIndex(v => /^fr(-|$)/i.test(v.lang) && /Google/i.test(v.name));
        voiceSelectEn.value = String(googleEn >= 0 ? googleEn : (defaultEn >= 0 ? defaultEn : 0));
        voiceSelectFr.value = String(googleFr >= 0 ? googleFr : (defaultFr >= 0 ? defaultFr : 0));
      }

      // Some browsers populate voices asynchronously
      try {
        console.log('[TTS] Calling loadVoices');
        loadVoices();
        console.log('[TTS] Calling loadBooks');
        loadBooks();
        console.log('[TTS] Calling loadDocs');
        loadDocs();
        console.log('[TTS] Calling updateNextChapterButton');
        updateNextChapterButton();
        console.log('[TTS] Initialization complete');
      } catch (err) {
        console.error('[TTS] Initialization error:', err);
      }
      if (voices.length === 0) {
        window.speechSynthesis.onvoiceschanged = () => {
          loadVoices();
        };
      }

      // Restore saved rates
      let storedRateEn, storedRateFr, storedFont, storedShow;
      try {
        if (localStorageAvailable) {
          storedRateEn = localStorage.getItem(LS.rateEn);
          storedRateFr = localStorage.getItem(LS.rateFr);
        }
        if (storedRateEn) rateEn.value = String(Math.max(0.5, Math.min(2.0, Number(storedRateEn))));
        if (storedRateFr) rateFr.value = String(Math.max(0.5, Math.min(2.0, Number(storedRateFr))));
      } catch (e) { console.warn('[TTS] localStorage access error (rates):', e); }

      // Restore font size
      try {
        if (localStorageAvailable) storedFont = localStorage.getItem(LS.fontSize);
        const initialFont = storedFont ? Math.max(15, Math.min(26, Number(storedFont))) : 17;
        fontSizeInput.value = String(initialFont);
        document.documentElement.style.setProperty('--base-font', initialFont + 'px');
      } catch (e) { console.warn('[TTS] localStorage access error (font):', e); }

      // On book change, navigate to first chapter
      bookSelect.addEventListener('change', () => {
        const b = bookSelect.value;
        try { if (localStorageAvailable) localStorage.setItem(LS.book, b); } catch(e) { console.warn('[TTS] localStorage set error (book):', e); }
        const url = new URL(window.location.href);
        url.searchParams.set('book', b);
        url.searchParams.delete('doc');
        window.location.href = url.toString();
      });
      // On chapter change, navigate within book
      docSelect.addEventListener('change', () => {
        const d = docSelect.value;
        // Save progress for current chapter before changing
        /// ahh we just need per book dont need this todo
        saveProgressToServer(currentPlayingIdx >= 0 ? currentPlayingIdx : 0);
        try { if (localStorageAvailable) localStorage.setItem(LS.doc, d); } catch(e) { console.warn('[TTS] localStorage set error (doc):', e); }
        const url = new URL(window.location.href);
        url.searchParams.set('book', bookSelect.value || currentBook);
        url.searchParams.set('doc', d);
        window.location.href = url.toString();
      });

      function updateNextChapterButton() {
        const idx = docSelect.selectedIndex >= 0 ? docSelect.selectedIndex : docs.indexOf(docSelect.value || currentDoc);
        const hasNext = idx >= 0 && idx < docs.length - 1;
        nextChapterBtn.style.display = hasNext ? 'inline-block' : 'none';
        
        if (hasNext) {
          const nextIdx = idx + 1;
          const nextDoc = docs[nextIdx];
          const isFlashback = currentBook && currentBook.toLowerCase().includes('flashback');
          let label;
          if (isFlashback) {
            const filename = String(nextDoc).split('/').pop().split('\\').pop();
            const match = filename.match(/chapter(\d+)/i);
            label = match ? `Chapter ${parseInt(match[1], 10)}` : filename;
          } else {
            label = (Array.isArray(docLabels) && docLabels[nextIdx]) ? String(docLabels[nextIdx]) : String(nextDoc);
          }
          if (label.length > 30) label = label.slice(0, 27) + '…';
          nextChapterBtn.textContent = `Next Chapter: ${label} →`;
        }
      }
      docSelect.addEventListener('change', updateNextChapterButton);
      // Book change triggers navigation; next-chapter button will update on the new page

      nextChapterBtn.addEventListener('click', () => {
        const idx = docSelect.selectedIndex >= 0 ? docSelect.selectedIndex : docs.indexOf(docSelect.value || currentDoc);
        if (idx < 0 || idx >= docs.length - 1) return;
        const nextDoc = docs[idx + 1];
        // Save progress for current chapter
        saveProgressToServer(currentPlayingIdx >= 0 ? currentPlayingIdx : 0);
        try { if (localStorageAvailable) localStorage.setItem(LS.doc, nextDoc); } catch(e) { console.warn('[TTS] localStorage set error (nextDoc):', e); }
        const url = new URL(window.location.href);
        url.searchParams.set('book', bookSelect.value || currentBook);
        url.searchParams.set('doc', nextDoc);
        window.location.href = url.toString();
      });

      // Persist rate changes
      rateEn.addEventListener('input', () => {
        try { if (localStorageAvailable) localStorage.setItem(LS.rateEn, rateEn.value); } catch(e) { console.warn('[TTS] localStorage set error (rateEn):', e); }
      });
      rateFr.addEventListener('input', () => {
        try { if (localStorageAvailable) localStorage.setItem(LS.rateFr, rateFr.value); } catch(e) { console.warn('[TTS] localStorage set error (rateFr):', e); }
      });

      // Persist font size changes
      fontSizeInput.addEventListener('input', () => {
        const size = Math.max(15, Math.min(26, Number(fontSizeInput.value)));
        document.documentElement.style.setProperty('--base-font', size + 'px');
        try { if (localStorageAvailable) localStorage.setItem(LS.fontSize, String(size)); } catch(e) { console.warn('[TTS] localStorage set error (fontSize):', e); }
      });

      // Settings panel toggle (persisted in localStorage)
      const LS_SETTINGS = 'tts.settingsOpen';
      let settingsOpenStored;
      try { if (localStorageAvailable) settingsOpenStored = localStorage.getItem(LS_SETTINGS); } catch(e) { console.warn('[TTS] localStorage get error (settings):', e); }
      const isOpen = settingsOpenStored === '1';
      if (isOpen) settingsPanel.classList.add('open');
      settingsToggleBtn.addEventListener('click', () => {
        settingsPanel.classList.toggle('open');
        try { if (localStorageAvailable) localStorage.setItem(LS_SETTINGS, settingsPanel.classList.contains('open') ? '1' : '0'); } catch(e) { console.warn('[TTS] localStorage set error (settings):', e); }
      });

      function applyLanguageFilter() {
        const val = showLangSelect.value || 'both';
        paras.forEach(el => {
          const lang = el.getAttribute('data-lang');
          const hide = (val === 'en' && lang === 'fr') || (val === 'fr' && lang === 'en');
          if (hide) el.classList.add('hidden'); else el.classList.remove('hidden');
        });
      }

      // Restore language visibility preference
      try {
        let storedShow;
        if (localStorageAvailable) storedShow = localStorage.getItem(LS.showLang);
        showLangSelect.value = storedShow || 'both';
      } catch (e) { console.warn('[TTS] localStorage access error (showLang):', e); }
      applyLanguageFilter();

      // Change visibility and reset playback when filter changes
      showLangSelect.addEventListener('change', () => {
        try { if (localStorageAvailable) localStorage.setItem(LS.showLang, showLangSelect.value); } catch(e) { console.warn('[TTS] localStorage set error (showLang):', e); }
        applyLanguageFilter();
        window.speechSynthesis.cancel();
        currentIndex = -1;
        paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
      });

      function speakParagraphs(startIdx = 0) {
        // Build queue from server-provided paragraphData with language hints and current visibility filter
        const val = showLangSelect.value || 'both';
        let items = paragraphData.map((item, idx) => ({ text: String(item.text || ''), lang: String(item.lang || 'en'), idx }));
        if (val === 'en') items = items.filter(it => it.lang === 'en');
        else if (val === 'fr') items = items.filter(it => it.lang === 'fr');
        queue = items;
        // Map DOM index to position in filtered queue
        let startPos = queue.findIndex(it => it.idx === startIdx);
        if (startPos < 0) startPos = 0;
        currentIndex = startPos;
        if (DEBUG_TTS) console.log(`[TTS] speakParagraphs startIdx=${startIdx} filter=${val} queueLen=${queue.length} startPos=${startPos}`);
        requestWakeLock().catch(() => {});
        speakNext();
      }

      function markPlaying(idx) {
        try {
          currentPlayingIdx = idx;
          const el = paras[idx];
          if (el) {
            const current = paragraphData[idx];
            const currentLang = current && current.lang;

            // Only clear and highlight for French paragraphs
            if (currentLang === 'fr') {
              paras.forEach(el => { el.classList.remove('playing'); });
              el.classList.add('playing');
              
              // Scroll to the previous visible paragraph for each French section
              let prevIdx = idx - 1;
              while (prevIdx >= 0 && paras[prevIdx] && paras[prevIdx].classList.contains('hidden')) prevIdx--;
              const scrollToIdx = prevIdx >= 0 ? prevIdx : idx;
              if (scrollToIdx >= 0) {
                window.location.hash = '#p' + scrollToIdx;
              }
            }
          }
        } catch (e) {
          console.error('[TTS] markPlaying error:', e);
        }
      }

      let speakNextCallDepth = 0;
      const MAX_SPEAK_DEPTH = 100;

      function speakNext() {
        speakNextCallDepth++;
        if (speakNextCallDepth > MAX_SPEAK_DEPTH) {
          console.error('[TTS] RECURSION LIMIT HIT - stopping to prevent stack overflow');
          speakNextCallDepth = 0;
          return;
        }
        
        if (currentIndex < 0 || currentIndex >= queue.length) {
          currentIndex = 1000;
          currentPlayingIdx = -1;
          paras.forEach(el => { el.classList.remove('playing'); });
          speakNextCallDepth = 0;
          return; // stop at end; do not restart
        }
        const item = queue[currentIndex];
        if (DEBUG_TTS) console.log(`[TTS] speakNext currentIndex=${currentIndex}/${queue.length} lang=${item.lang} idx=${item.idx} textLen=${item.text?.length || 0}`);
        const u = new SpeechSynthesisUtterance(item.text);
        // Pick voice by language
        const vIdx = item.lang === 'fr' ? Number(voiceSelectFr.value) : Number(voiceSelectEn.value);
        const v = voices[vIdx] || voices.find(v => v.default) || voices[0];
        if (v) u.voice = v;
        // Also set lang hint to guide synthesis engine
        u.lang = item.lang === 'fr' ? 'fr-FR' : 'en-US';
        // Use per-language rate
        u.rate = item.lang === 'fr' ? Number(rateFr.value) : Number(rateEn.value);
        u.pitch = Number(pitchInput.value);
        u.onstart = () => { if (DEBUG_TTS) console.log(`[TTS] onstart idx=${item.idx} lang=${item.lang}`); userPaused = false; speakNextCallDepth = 0; markPlaying(item.idx); };
        u.onend = () => {
          if (DEBUG_TTS) console.log(`[TTS] onend idx=${item.idx}`);
          // Save progress after each paragraph
          saveProgressToServer(item.idx + 1); // Save the next paragraph index
          if (currentIndex + 1 >= queue.length) {
            // Finished last paragraph; clear playing state and stop
            paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
            currentIndex = 1000;
            speakNextCallDepth = 0;
            releaseWakeLock();
            return;
          }
          currentIndex++;
          speakNext();
        };
        u.onerror = (e) => {
          console.warn('[TTS] error:', e.error);
          if (currentIndex + 1 >= queue.length) {
            paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
            currentIndex = 1000;
            speakNextCallDepth = 0;
            return;
          }
          currentIndex++;
          speakNext();
        };
        window.speechSynthesis.speak(u);
      }

      btnPlay.addEventListener('click', () => {
        window.speechSynthesis.cancel();
        requestWakeLock().catch(() => {});
        speakParagraphs(0);
      });
      btnPause.addEventListener('click', () => {
        if (DEBUG_TTS) console.log('[TTS] button pause');
        userPaused = true;
        window.speechSynthesis.pause();
      });
      btnResume.addEventListener('click', () => {
        if (DEBUG_TTS) console.log('[TTS] button resume');
        requestWakeLock().catch(() => {});
        userPaused = false;
        window.speechSynthesis.resume();
      });
      btnStop.addEventListener('click', () => {
        window.speechSynthesis.cancel();
        currentIndex = -1;
        paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
        releaseWakeLock();
      });

      // Click a paragraph to start reading from it
      const contentEl = document.getElementById('content');
      contentEl.addEventListener('click', (ev) => {
        // Ignore synthetic clicks that immediately follow a touch
        if (Date.now() - lastTouchTs < 400) return;
        const target = ev.target;
        const para = (target && target.closest) ? target.closest('.para') : null;
        if (!para) return;
        const idx = Number(para.getAttribute('data-index'));
        if (DEBUG_TTS) console.log(`[TTS] click paragraph idx=${idx} currentPlayingIdx=${currentPlayingIdx}`);
        // If clicking the currently playing paragraph, toggle pause/resume
        if (idx === currentPlayingIdx) {
          const s = window.speechSynthesis;
          const shouldResume = s.paused || userPaused;
          if (shouldResume) {
            if (DEBUG_TTS) console.log(`[TTS] action: resume (click current) paused=${s.paused} userPaused=${userPaused}`);
            userPaused = false;
            resumeOrRestart(idx);
          } else if (s.speaking) {
            if (DEBUG_TTS) console.log('[TTS] action: pause (click current)');
            userPaused = true;
            s.pause();
          } else {
            if (DEBUG_TTS) console.log('[TTS] action: restart (click current idle)');
            s.cancel();
            requestWakeLock().catch(() => {});
            speakParagraphs(idx);
          }
          return;
        }
        // Otherwise restart from the clicked paragraph
        if (DEBUG_TTS) console.log('[TTS] action: restart (click other)');
        window.speechSynthesis.cancel();
        requestWakeLock().catch(() => {});
        speakParagraphs(idx);
      });

      // Keyboard: suppress Tab navigation; Space toggles pause/resume (robust resume)
      window.addEventListener('keydown', (e) => {
        // Always suppress Tab so it doesn't move focus
        if (e.key === 'Tab' || e.code === 'Tab') {
          if (DEBUG_TTS) console.log('[TTS] Tab suppressed');
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
        if (!isSpace) return;
        const tag = (document.activeElement && document.activeElement.tagName) || '';
        if (/^(INPUT|TEXTAREA|SELECT|BUTTON)$/i.test(tag)) return; // don't hijack space in controls
        e.preventDefault();
        const s = window.speechSynthesis;
        // Resume if paused (or flagged paused), otherwise pause if speaking
        if (s.paused || userPaused) {
          if (DEBUG_TTS) console.log(`[TTS] action: resume (space) paused=${s.paused} userPaused=${userPaused}`);
          userPaused = false;
          requestWakeLock().catch(() => {});
          const curIdx = (currentIndex >= 0 && currentIndex < queue.length) ? (queue[currentIndex]?.idx ?? 0) : 0;
          resumeOrRestart(curIdx);
          return;
        }
        if (s.speaking) {
          if (DEBUG_TTS) console.log('[TTS] action: pause (space)');
          userPaused = true;
          s.pause();
          return;
        }
        // If idle, do nothing; user can click a paragraph or press Play to start
      });

      // Auto-start on load for convenience
      window.addEventListener('load', () => {
        console.log('[TTS] Page load event fired');
        // Clear hash that might be keeping page scrolled down
        if (window.location.hash) {
          history.replaceState(null, null, ' ');
        }
        // Scroll to top using ALL methods
        window.scrollTo(0, 0);
        document.documentElement.scrollTop = 0;
        document.body.scrollTop = 0;
        // Force scroll again after a frame
        requestAnimationFrame(() => {
          window.scrollTo(0, 0);
          document.documentElement.scrollTop = 0;
          document.body.scrollTop = 0;
          console.log('[TTS] Scrolled to top');
        });
        // Small delay to allow voices to populate
        // setTimeout(() => {
        //   console.log('[TTS] Starting auto-play from paragraph 0');
        //   speakParagraphs(0);
        // }, 300);
        // Start from saved position - just position, don't auto-start
        setTimeout(() => {
          console.log('[TTS] Positioning to saved paragraph:', savedParagraphIndex);
          if (savedParagraphIndex > 0 && savedParagraphIndex < paras.length) {
            // Scroll to and highlight the saved paragraph
            const el = paras[savedParagraphIndex];
            if (el) {
              el.scrollIntoView({ behavior: 'smooth', block: 'center' });
              el.classList.add('playing'); // Highlight it
            }
          }
        }, 300);
      });

      // Clean up wake lock on unload
      window.addEventListener('beforeunload', () => { 
        releaseWakeLock(); 
      });
    </script>
  </body>
</html>
