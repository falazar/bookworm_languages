<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title><%= title %></title>
    <style>
      /* Dark theme for comfortable reading */
      :root { --base-font: 17px; }
      body { font-family: system-ui, Arial, sans-serif; margin: 20px 10%; font-size: var(--base-font); background: #000; color: #e6e6e6; }
      header { display: flex; align-items: center; justify-content: space-between; gap: 12px; color: #d0d0d0; }
      .header-left { display: flex; align-items: center; gap: 12px; min-width: 0; }
      .book-name { max-width: 50vw; }
      .book-name code { display: inline-block; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .controls { display: flex; flex-wrap: wrap; gap: 12px; margin: 12px 0; }
      label { display: inline-flex; align-items: center; gap: 6px; }
      textarea { width: 100%; min-height: 120px; background: #0c0c0c; color: #e6e6e6; border: 1px solid #333; }
      input[type="range"] { min-width: 220px; }
      /* Unified dropdown styling */
      select {
        display: inline-block;
        width: fit-content;
        min-width: 0;
        max-width: 60vw;
        padding: 8px 12px;
        font-size: 16px;
        line-height: 1.25;
        background: #1c1f29;
        color: #f0f0f0;
        border: 1px solid #444;
        border-radius: 6px;
      }
      input[type="range"] { accent-color: #66a3ff; }
      button { padding: 6px 12px; background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; }
      .btn { padding: 6px 12px; background: #1a1a1a; color: #f0f0f0; border: 1px solid #333; border-radius: 4px; text-decoration: none; display: inline-block; white-space: nowrap; }
      .settings-toggle { margin-left: 12px; }
      .settings-panel { display: none; flex-wrap: wrap; gap: 12px; margin-top: 12px; }
      .settings-panel.open { display: flex; }
      

      .para { margin: 8px 0; padding: 6px 8px; border-left: 3px solid #222; background: #0a0a0a; }
      /* Slight highlight and bold for both FR and EN paragraphs of the active pair */
      .para.paired { box-shadow: inset 0 0 0 9999px rgba(255, 255, 180, 0.06); font-weight: 700; }
      /* Stronger emphasis and light yellow text for the paragraph being read */
      .para.playing { border-left-color: #ffd54f; background: #2a240f; font-weight: 700; color: #ffeaa7; }
      .para.hidden { display: none; }
      /* Tint by language on dark */
      .para[data-lang="fr"] { border-left-color: #d83b01; background: #1a0f0a; }
      .para[data-lang="en"] { border-left-color: #107c10; background: #0f1a0f; }

      footer { margin-top: 16px; font-size: 13px; color: #a0a0a0; }

      .legend { display: flex; gap: 18px; align-items: center; margin: 32px 0 12px; font-size: 13px; color: #a0a0a0; }
      .swatch { width: 12px; height: 12px; display: inline-block; border: 1px solid #555; margin-right: 6px; }
      .swatch.fr { background: #1d120d; border-color: #d83b01; }
      .swatch.en { background: #101d10; border-color: #107c10; }
      .break { flex-basis: 100%; height: 0; }
    </style>
  </head>
  <body>
    <header>
      <div class="header-left">
        <div class="book-name"><code><%= typeof book !== 'undefined' ? book : '' %></code></div>
      </div>
      <div>
        <a href="/books" class="btn">← Back to Books</a>
      </div>
    </header>

    <div class="controls">
      <label>
        Chapter
        <select id="docSelect"></select>
      </label>
      <button id="settingsToggle" class="btn settings-toggle">Settings</button>

      <div id="settingsPanel" class="settings-panel">
        <label>
          Show
          <select id="showLang">
            <option value="both">Both</option>
            <option value="en">English only</option>
            <option value="fr">French only</option>
          </select>
        </label>
        <label style="display:none">
          Book
          <select id="bookSelect"></select>
        </label>

        <label>
          Font Size
          <input id="fontSize" type="range" min="15" max="26" step="1" value="17" />
        </label>
        <div class="break"></div>
        <label>
          English Voice
          <select id="voiceSelectEn"></select>
        </label>
        <label>
          French Voice
          <select id="voiceSelectFr"></select>
        </label>
        <div class="break"></div>
        <label>
          English Rate
          <input id="rateEn" type="range" min="0.5" max="2.0" step="0.1" value="1.0" />
        </label>
        <label>
          French Rate
          <input id="rateFr" type="range" min="0.5" max="2.0" step="0.1" value="1.0" />
        </label>
        <label>
          Pitch
          <input id="pitch" type="range" min="0.8" max="1.2" step="0.05" value="1.0" />
        </label>
        <button id="play">Play</button>
        <button id="pause">Pause</button>
        <button id="resume">Resume</button>
        <button id="stop">Stop</button>
      </div>
    </div>

    <div class="legend">
      <span><span class="swatch fr"></span>French (FR)</span>
      <span><span class="swatch en"></span>English (EN)</span>
      <span>Currently playing is highlighted.</span>
    </div>

    <section id="content">
      <% paragraphs.forEach(function(p, idx) { %>
        <div class="para" data-index="<%= idx %>" data-lang="<%= p.lang %>">
          <span><%= p.text %></span>
        </div>
      <% }) %>
    </section>
    <div style="margin-top: 16px;">
      <button id="nextChapter" class="btn">Next Chapter →</button>
    </div>

    <footer>
      Tip: Open this page in Chrome/Edge to access high-quality voices. Use the voice list to pick a "Google" voice if available.
    </footer>

    <script>
      const bookSelect = document.getElementById('bookSelect');
      const docSelect = document.getElementById('docSelect');
      const voiceSelectEn = document.getElementById('voiceSelectEn');
      const rateEn = document.getElementById('rateEn');
      const rateFr = document.getElementById('rateFr');
      const pitchInput = document.getElementById('pitch');
      const fontSizeInput = document.getElementById('fontSize');
      const showLangSelect = document.getElementById('showLang');
      const settingsToggleBtn = document.getElementById('settingsToggle');
      const settingsPanel = document.getElementById('settingsPanel');
      const btnPlay = document.getElementById('play');
      const btnPause = document.getElementById('pause');
      const btnResume = document.getElementById('resume');
      const btnStop = document.getElementById('stop');
      const paras = Array.from(document.querySelectorAll('.para'));
      const nextChapterBtn = document.getElementById('nextChapter');

      // Debug logging flag (enable via ?debug=1)
      const DEBUG_TTS = /[?&]debug=1/.test(location.search);
      function logState(prefix) {
        try {
          const s = window.speechSynthesis;
          if (DEBUG_TTS) console.log(`[TTS] ${prefix} | speaking=${s.speaking} paused=${s.paused} pending=${s.pending}`);
        } catch (_) {}
      }

      let voices = [];
      let queue = [];
      let currentIndex = -1;
      let userPaused = false;
      // Track current FR/EN pair anchor index to stabilize scrolling
      let lastPairAnchor = -1;
      // Suppress synthetic click after touch to avoid double-handling
      let lastTouchTs = 0;

      // Keep screen awake while reading using the Screen Wake Lock API
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if (navigator.wakeLock && !wakeLock) {
            wakeLock = await navigator.wakeLock.request('screen');
            wakeLock.addEventListener('release', () => { wakeLock = null; });
          }
        } catch (err) {
          console.warn('Wake Lock error:', err);
          wakeLock = null;
        }
      }
      async function releaseWakeLock() {
        try {
          if (wakeLock) {
            await wakeLock.release();
            wakeLock = null;
          }
        } catch (_) {}
      }

      // Try resume, fallback to restart if engine stays paused or idle
      function resumeOrRestart(idx) {
        logState('resumeOrRestart: before resume');
        try { requestWakeLock(); } catch(_) {}
        try { window.speechSynthesis.resume(); } catch(_) {}
        setTimeout(() => {
          try {
            const s = window.speechSynthesis;
            // If still paused OR not speaking and no pending utterances, restart from the same paragraph
            if (s.paused || (!s.speaking && !s.pending)) {
              logState('resumeOrRestart: fallback restart');
              s.cancel();
              requestWakeLock();
              speakParagraphs(idx);
            } else {
              logState('resumeOrRestart: resume took effect');
            }
          } catch(_) {}
        }, 180);
      }

      // Reacquire on visibility change (wake locks can be released when tab is hidden)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && (window.speechSynthesis.speaking || window.speechSynthesis.paused)) {
          requestWakeLock();
        }
      });

      // Populate book/chapter selectors from server-provided list
      const books = <%- JSON.stringify(typeof books !== 'undefined' ? books : []) %>;
      const currentBook = <%- JSON.stringify(typeof book !== 'undefined' ? book : '') %>;
      const docs = <%- JSON.stringify(typeof docs !== 'undefined' ? docs : []) %>;
      const docLabels = <%- JSON.stringify(typeof docLabels !== 'undefined' ? docLabels : []) %>;
      const currentDoc = <%- JSON.stringify(typeof doc !== 'undefined' ? doc : '') %>;
      const paragraphData = <%- JSON.stringify(paragraphs || []) %>;

      // Local storage keys
      const LS = {
        book: 'tts.selectedBook',
        doc: 'tts.selectedDoc',
        rateEn: 'tts.rateEn',
        rateFr: 'tts.rateFr',
        fontSize: 'tts.fontSize',
        showLang: 'tts.showLang',
      };

      function loadBooks() {
        bookSelect.innerHTML = '';
        books.forEach(b => {
          const opt = document.createElement('option');
          opt.value = b;
          opt.textContent = b;
          bookSelect.appendChild(opt);
        });
        const storedBook = localStorage.getItem(LS.book);
        const chosenBook = storedBook && books.includes(storedBook) ? storedBook : currentBook;
        if (chosenBook) {
          bookSelect.value = chosenBook;
        } else if (books.length > 0) {
          // No saved or current book; default to first and navigate to load chapters
          bookSelect.value = books[0];
          const url = new URL(window.location.href);
          url.searchParams.set('book', books[0]);
          url.searchParams.delete('doc');
          window.location.replace(url.toString());
          return;
        }
      }

      function loadDocs() {
        docSelect.innerHTML = '';
        docs.forEach((d, idx) => {
          const opt = document.createElement('option');
          opt.value = d;
          let label = (Array.isArray(docLabels) && docLabels[idx]) ? String(docLabels[idx]) : String(d);
          if (label.length > 30) label = label.slice(0, 27) + '…';
          opt.textContent = label;
          docSelect.appendChild(opt);
        });
        const storedDoc = localStorage.getItem(LS.doc);
        const chosenDoc = storedDoc && docs.includes(storedDoc) ? storedDoc : currentDoc;
        if (chosenDoc) docSelect.value = chosenDoc;
      }

      function loadVoices() {
        voices = window.speechSynthesis.getVoices();
        // Populate English voices
        voiceSelectEn.innerHTML = '';
        voices.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `${v.name} — ${v.lang}${v.default ? ' (default)' : ''}`;
          voiceSelectEn.appendChild(opt);
        });
        // Populate French voices
        voiceSelectFr.innerHTML = '';
        voices.forEach((v, i) => {
          const opt = document.createElement('option');
          opt.value = String(i);
          opt.textContent = `${v.name} — ${v.lang}${v.default ? ' (default)' : ''}`;
          voiceSelectFr.appendChild(opt);
        });

        // Prefer language-appropriate defaults
        const defaultEn = voices.findIndex(v => /^en(-|$)/i.test(v.lang));
        const defaultFr = voices.findIndex(v => /^fr(-|$)/i.test(v.lang));
        const googleEn = voices.findIndex(v => /^en(-|$)/i.test(v.lang) && /Google/i.test(v.name));
        const googleFr = voices.findIndex(v => /^fr(-|$)/i.test(v.lang) && /Google/i.test(v.name));
        voiceSelectEn.value = String(googleEn >= 0 ? googleEn : (defaultEn >= 0 ? defaultEn : 0));
        voiceSelectFr.value = String(googleFr >= 0 ? googleFr : (defaultFr >= 0 ? defaultFr : 0));
      }

      // Some browsers populate voices asynchronously
      loadVoices();
      loadBooks();
      loadDocs();
      updateNextChapterButton();
      if (voices.length === 0) {
        window.speechSynthesis.onvoiceschanged = () => {
          loadVoices();
        };
      }

      // Restore saved rates
      const storedRateEn = localStorage.getItem(LS.rateEn);
      const storedRateFr = localStorage.getItem(LS.rateFr);
      if (storedRateEn) rateEn.value = String(Math.max(0.5, Math.min(2.0, Number(storedRateEn))));
      if (storedRateFr) rateFr.value = String(Math.max(0.5, Math.min(2.0, Number(storedRateFr))));

      // Restore font size
      const storedFont = localStorage.getItem(LS.fontSize);
      const initialFont = storedFont ? Math.max(15, Math.min(26, Number(storedFont))) : 17;
      fontSizeInput.value = String(initialFont);
      document.documentElement.style.setProperty('--base-font', initialFont + 'px');

      // On book change, navigate to first chapter
      bookSelect.addEventListener('change', () => {
        const b = bookSelect.value;
        localStorage.setItem(LS.book, b);
        const url = new URL(window.location.href);
        url.searchParams.set('book', b);
        url.searchParams.delete('doc');
        window.location.href = url.toString();
      });
      // On chapter change, navigate within book
      docSelect.addEventListener('change', () => {
        const d = docSelect.value;
        localStorage.setItem(LS.doc, d);
        const url = new URL(window.location.href);
        url.searchParams.set('book', bookSelect.value || currentBook);
        url.searchParams.set('doc', d);
        window.location.href = url.toString();
      });

      function updateNextChapterButton() {
        const idx = docSelect.selectedIndex >= 0 ? docSelect.selectedIndex : docs.indexOf(docSelect.value || currentDoc);
        const hasNext = idx >= 0 && idx < docs.length - 1;
        nextChapterBtn.style.display = hasNext ? 'inline-block' : 'none';
      }
      docSelect.addEventListener('change', updateNextChapterButton);
      // Book change triggers navigation; next-chapter button will update on the new page

      nextChapterBtn.addEventListener('click', () => {
        const idx = docSelect.selectedIndex >= 0 ? docSelect.selectedIndex : docs.indexOf(docSelect.value || currentDoc);
        if (idx < 0 || idx >= docs.length - 1) return;
        const nextDoc = docs[idx + 1];
        localStorage.setItem(LS.doc, nextDoc);
        const url = new URL(window.location.href);
        url.searchParams.set('book', bookSelect.value || currentBook);
        url.searchParams.set('doc', nextDoc);
        window.location.href = url.toString();
      });

      // Persist rate changes
      rateEn.addEventListener('input', () => {
        localStorage.setItem(LS.rateEn, rateEn.value);
      });
      rateFr.addEventListener('input', () => {
        localStorage.setItem(LS.rateFr, rateFr.value);
      });

      // Persist font size changes
      fontSizeInput.addEventListener('input', () => {
        const size = Math.max(15, Math.min(26, Number(fontSizeInput.value)));
        document.documentElement.style.setProperty('--base-font', size + 'px');
        localStorage.setItem(LS.fontSize, String(size));
      });

      // Settings panel toggle (persisted in localStorage)
      const LS_SETTINGS = 'tts.settingsOpen';
      const settingsOpenStored = localStorage.getItem(LS_SETTINGS);
      const isOpen = settingsOpenStored === '1';
      if (isOpen) settingsPanel.classList.add('open');
      settingsToggleBtn.addEventListener('click', () => {
        settingsPanel.classList.toggle('open');
        localStorage.setItem(LS_SETTINGS, settingsPanel.classList.contains('open') ? '1' : '0');
      });

      function applyLanguageFilter() {
        const val = showLangSelect.value || 'both';
        paras.forEach(el => {
          const lang = el.getAttribute('data-lang');
          const hide = (val === 'en' && lang === 'fr') || (val === 'fr' && lang === 'en');
          if (hide) el.classList.add('hidden'); else el.classList.remove('hidden');
        });
      }

      // Restore language visibility preference
      const storedShow = localStorage.getItem(LS.showLang);
      showLangSelect.value = storedShow || 'both';
      applyLanguageFilter();

      // Change visibility and reset playback when filter changes
      showLangSelect.addEventListener('change', () => {
        localStorage.setItem(LS.showLang, showLangSelect.value);
        applyLanguageFilter();
        window.speechSynthesis.cancel();
        currentIndex = -1;
        paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
      });

      function speakParagraphs(startIdx = 0) {
        // Build queue from server-provided paragraphData with language hints and current visibility filter
        const val = showLangSelect.value || 'both';
        let items = paragraphData.map((item, idx) => ({ text: String(item.text || ''), lang: String(item.lang || 'en'), idx }));
        if (val === 'en') items = items.filter(it => it.lang === 'en');
        else if (val === 'fr') items = items.filter(it => it.lang === 'fr');
        queue = items;
        // Map DOM index to position in filtered queue
        let startPos = queue.findIndex(it => it.idx === startIdx);
        if (startPos < 0) startPos = 0;
        currentIndex = startPos;
        lastPairAnchor = -1;
        if (DEBUG_TTS) console.log(`[TTS] speakParagraphs startIdx=${startIdx} filter=${val} queueLen=${queue.length} startPos=${startPos}`);
        requestWakeLock();
        speakNext();
      }

      function markPlaying(idx) {
        // Clear previous highlights
        paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
        const el = paras[idx];
        if (el) {
          // Determine paired paragraph (neighbor with opposite language)
          const current = paragraphData[idx];
          const currentLang = current && current.lang;
          let pairIdx = -1;
          if (currentLang === 'fr') {
            if (idx > 0 && paragraphData[idx - 1].lang === 'en') pairIdx = idx - 1; else if (idx + 1 < paragraphData.length && paragraphData[idx + 1].lang === 'en') pairIdx = idx + 1;
          } else if (currentLang === 'en') {
            if (idx > 0 && paragraphData[idx - 1].lang === 'fr') pairIdx = idx - 1; else if (idx + 1 < paragraphData.length && paragraphData[idx + 1].lang === 'fr') pairIdx = idx + 1;
          }

          // Apply highlights: slight background on both, stronger highlight + yellow text on current
          el.classList.add('paired');
          el.classList.add('playing');
          if (pairIdx >= 0 && paras[pairIdx]) paras[pairIdx].classList.add('paired');

          // Only adjust scroll when entering a NEW FR/EN pair
          const anchor = pairIdx >= 0 ? Math.min(idx, pairIdx) : idx;
          const isNewPair = anchor !== lastPairAnchor;
          if (isNewPair) {
            // Scroll the PREVIOUS VISIBLE paragraph to the top (fallback to current if none)
            let prevIdx = idx - 1;
            while (prevIdx >= 0 && paras[prevIdx] && paras[prevIdx].classList.contains('hidden')) prevIdx--;
            const scrollEl = prevIdx >= 0 ? paras[prevIdx] : el;
            if (scrollEl) {
              const header = document.querySelector('header');
              const headerHeight = header ? header.offsetHeight : 0;
              const rect = scrollEl.getBoundingClientRect();
              const absoluteTop = rect.top + window.scrollY;
              const targetTop = Math.max(0, absoluteTop - headerHeight - 12);
              window.scrollTo({ top: targetTop, behavior: 'smooth' });
            }
            lastPairAnchor = anchor;
          }
        }
      }

      function speakNext() {
        if (currentIndex < 0 || currentIndex >= queue.length) {
          currentIndex = 1000;
          paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
          lastPairAnchor = -1;
          return; // stop at end; do not restart
        }
        const item = queue[currentIndex];
        if (DEBUG_TTS) console.log(`[TTS] speakNext currentIndex=${currentIndex}/${queue.length} lang=${item.lang} idx=${item.idx} textLen=${item.text?.length || 0}`);
        const u = new SpeechSynthesisUtterance(item.text);
        // Pick voice by language
        const vIdx = item.lang === 'fr' ? Number(voiceSelectFr.value) : Number(voiceSelectEn.value);
        const v = voices[vIdx] || voices.find(v => v.default) || voices[0];
        if (v) u.voice = v;
        // Also set lang hint to guide synthesis engine
        u.lang = item.lang === 'fr' ? 'fr-FR' : 'en-US';
        // Use per-language rate
        u.rate = item.lang === 'fr' ? Number(rateFr.value) : Number(rateEn.value);
        u.pitch = Number(pitchInput.value);
        u.onstart = () => { if (DEBUG_TTS) console.log(`[TTS] onstart idx=${item.idx} lang=${item.lang}`); userPaused = false; markPlaying(item.idx); };
        u.onend = () => {
          if (DEBUG_TTS) console.log(`[TTS] onend idx=${item.idx}`);
          if (currentIndex + 1 >= queue.length) {
            // Finished last paragraph; clear playing state and stop
            paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
            currentIndex = 1000;
            lastPairAnchor = -1;
            releaseWakeLock();
            return;
          }
          currentIndex++;
          speakNext();
        };
        u.onerror = (e) => {
          console.warn('[TTS] error:', e.error);
          if (currentIndex + 1 >= queue.length) {
            paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
            currentIndex = 1000;
            lastPairAnchor = -1;
            return;
          }
          currentIndex++;
          speakNext();
        };
        window.speechSynthesis.speak(u);
      }

      btnPlay.addEventListener('click', () => {
        window.speechSynthesis.cancel();
        requestWakeLock();
        speakParagraphs(0);
      });
      btnPause.addEventListener('click', () => {
        if (DEBUG_TTS) console.log('[TTS] button pause');
        userPaused = true;
        window.speechSynthesis.pause();
      });
      btnResume.addEventListener('click', () => {
        if (DEBUG_TTS) console.log('[TTS] button resume');
        requestWakeLock();
        userPaused = false;
        window.speechSynthesis.resume();
      });
      btnStop.addEventListener('click', () => {
        window.speechSynthesis.cancel();
        currentIndex = -1;
        paras.forEach(el => { el.classList.remove('playing'); el.classList.remove('paired'); });
        lastPairAnchor = -1;
        releaseWakeLock();
      });

      // Click a paragraph to start reading from it
      const contentEl = document.getElementById('content');
      contentEl.addEventListener('click', (ev) => {
        // Ignore synthetic clicks that immediately follow a touch
        if (Date.now() - lastTouchTs < 400) return;
        const target = ev.target;
        const para = (target && target.closest) ? target.closest('.para') : null;
        if (!para) return;
        const idx = Number(para.getAttribute('data-index'));
        if (DEBUG_TTS) console.log(`[TTS] click paragraph idx=${idx} playing=${para.classList.contains('playing')}`);
        // If clicking the currently playing paragraph, toggle pause/resume
        if (para.classList.contains('playing')) {
          const s = window.speechSynthesis;
          const shouldResume = s.paused || userPaused;
          if (shouldResume) {
            if (DEBUG_TTS) console.log(`[TTS] action: resume (click current) paused=${s.paused} userPaused=${userPaused}`);
            userPaused = false;
            resumeOrRestart(idx);
          } else if (s.speaking) {
            if (DEBUG_TTS) console.log('[TTS] action: pause (click current)');
            userPaused = true;
            s.pause();
          } else {
            if (DEBUG_TTS) console.log('[TTS] action: restart (click current idle)');
            s.cancel();
            requestWakeLock();
            speakParagraphs(idx);
          }
          return;
        }
        // Otherwise restart from the clicked paragraph
        if (DEBUG_TTS) console.log('[TTS] action: restart (click other)');
        window.speechSynthesis.cancel();
        requestWakeLock();
        speakParagraphs(idx);
      });

      // Touch to start from the tapped paragraph (mobile)
      // contentEl.addEventListener('touchend', (ev) => {
      //   lastTouchTs = Date.now();
      //   try { if (ev.preventDefault) ev.preventDefault(); } catch(_) {}
      //   try { if (ev.stopPropagation) ev.stopPropagation(); } catch(_) {}
      //   const target = ev.target;
      //   const para = (target && target.closest) ? target.closest('.para') : null;
      //   if (!para) return;
      //   const idx = Number(para.getAttribute('data-index'));
      //   if (DEBUG_TTS) {
      //     try {
      //       const s = window.speechSynthesis;
      //       console.log(`[TTS] touch paragraph idx=${idx} playing=${para.classList.contains('playing')} speaking=${s.speaking} paused=${s.paused} pending=${s.pending}`);
      //     } catch(_) {}
      //   }
      //   // If tapping the currently playing paragraph, toggle pause/resume
      //   if (para.classList.contains('playing')) {
      //     const s = window.speechSynthesis;
      //     const shouldResume = s.paused || userPaused;
      //     if (shouldResume) {
      //       if (DEBUG_TTS) console.log(`[TTS] action: resume (touch current) paused=${s.paused} userPaused=${userPaused}`);
      //       userPaused = false;
      //       resumeOrRestart(idx);
      //     } else if (s.speaking) {
      //       if (DEBUG_TTS) console.log('[TTS] action: pause (touch current)');
      //       userPaused = true;
      //       s.pause();
      //     } else {
      //       if (DEBUG_TTS) console.log('[TTS] action: restart (touch current idle)');
      //       s.cancel();
      //       requestWakeLock();
      //       speakParagraphs(idx);
      //     }
      //     return;
      //   }
      //   // Otherwise restart from the tapped paragraph
      //   if (DEBUG_TTS) console.log('[TTS] action: restart (touch other)');
      //   window.speechSynthesis.cancel();
      //   requestWakeLock();
      //   speakParagraphs(idx);
      // }, { passive: false });

      // Keyboard: suppress Tab navigation; Space toggles pause/resume (robust resume)
      window.addEventListener('keydown', (e) => {
        // Always suppress Tab so it doesn't move focus
        if (e.key === 'Tab' || e.code === 'Tab') {
          if (DEBUG_TTS) console.log('[TTS] Tab suppressed');
          e.preventDefault();
          e.stopPropagation();
          return;
        }
        const isSpace = e.code === 'Space' || e.key === ' ' || e.key === 'Spacebar';
        if (!isSpace) return;
        const tag = (document.activeElement && document.activeElement.tagName) || '';
        if (/^(INPUT|TEXTAREA|SELECT|BUTTON)$/i.test(tag)) return; // don't hijack space in controls
        e.preventDefault();
        const s = window.speechSynthesis;
        // Resume if paused (or flagged paused), otherwise pause if speaking
        if (s.paused || userPaused) {
          if (DEBUG_TTS) console.log(`[TTS] action: resume (space) paused=${s.paused} userPaused=${userPaused}`);
          userPaused = false;
          requestWakeLock();
          const curIdx = (currentIndex >= 0 && currentIndex < queue.length) ? (queue[currentIndex]?.idx ?? 0) : 0;
          resumeOrRestart(curIdx);
          return;
        }
        if (s.speaking) {
          if (DEBUG_TTS) console.log('[TTS] action: pause (space)');
          userPaused = true;
          s.pause();
          return;
        }
        // If idle, do nothing; user can click a paragraph or press Play to start
      });

      // Auto-start on load for convenience
      window.addEventListener('load', () => {
        // On mobile, avoid auto-start so wake lock can be requested from a user gesture
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (!isMobile) {
          // Small delay to allow voices to populate
          setTimeout(() => speakParagraphs(0), 300);
        }
      });

      // Clean up wake lock on unload
      window.addEventListener('beforeunload', () => { releaseWakeLock(); });
    </script>
  </body>
</html>
